---
title: "MortgageKaggle"
author: "Aidan Morrison"
date: "18/08/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Starting a mortgage kaggle comp

What fun!!

## First lets install some likely packages

```{r settingup, message=F, warning=F}
install.packages("pacman")
library(pacman)
p_load("tidyverse")
p_load("lubridate")
p_load("scales")
p_load("ranger")
p_load("rpart")
p_load("rpart.plot")
p_load("xgboost")
p_load("pca")
p_load("glmnet")
p_load("skimr")
p_load("pROC")
```


## And the load in some data
```{r gettingdata, message=F, warning=F, cache=T}
application_test <- read_csv("~/allMortgage/application_test.csv")
application_train <- read_csv("~/allMortgage/application_train.csv")
bureau_balance <- read_csv("~/allMortgage/bureau_balance.csv")
bureau <- read_csv("~/allMortgage/bureau.csv")
credit_card_balance <- read_csv("~/allMortgage/credit_card_balance.csv")
HomeCredit_columns_description <- read_csv("~/allMortgage/HomeCredit_columns_description.csv")
installments_payments <- read_csv("~/allMortgage/installments_payments.csv")
POS_CASH_balance <- read_csv("~/allMortgage/POS_CASH_balance.csv")
previous_application <- read_csv("~/allMortgage/previous_application.csv")
sample_submission <- read_csv("~/allMortgage/sample_submission.csv")
```

## Take a Skim of the main sheet

```{r skim, cache=TRUE}
skim(application_train)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## Cut straight away to some quick results
```{r rpart, cache=T}

application_train_train_id <- application_train$SK_ID_CURR %>% sample(250000)
application_train_train <- application_train %>% filter(SK_ID_CURR %in% application_train_train_id)
application_train_test <- application_train %>% filter(!SK_ID_CURR %in% application_train_train_id)
#mod_rpart_1 <- rpart(data = application_train_train, formula = TARGET ~.)
#mod_rpart_1 %>% summary()
#plotcp(mod_rpart_1)
```
```{r plotrpart}
rpart.plot(mod_rpart_1)
```

## Maybe we can force a larger tree?
```{r rpart2, cache=TRUE}
#mod_rpart_2 <- rpart(data = application_train_train, formula = TARGET ~., cp = 0.001)
#plotcp(mod_rpart_2)
```
```{r plotrpart2}
rpart.plot(mod_rpart_2)
```

## Hard to read so let's inspect

```{r summrpart2}
summary(mod_rpart_2)
```

## Looks sensible, let's assess how good the model is

```{r evaluaterpart, cache=TRUE}
prediction <- predict(mod_rpart_2, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET)
```

## Where too from here?
Without all the data, without optimising depth, a single tree can still get significant more than half way to competitive scores.

Could just keep hacking...

Or maybe explore and understand the data


## Just what sort of data do we have?
It's worth looking at the diagram provided in this link <https://www.kaggle.com/c/home-credit-default-risk/data>

And also inspecting the description file that we have briefly

```{r descriptions}
HomeCredit_columns_description %>% head(n = 219)
```

```{r descriptplot, cache=TRUE}
HomeCredit_columns_description %>% 
  filter(X1  %in% c(1:50)) %>% 
  ggplot(aes(y = X1, col = Table))+
  geom_text(aes(x = 0, label = Row), size = 2, hjust = 0)+
  geom_text(aes(x = 8, label = Description), size = 2, hjust = 0)+
  scale_x_continuous(limits = c(-0, 25))+
  theme(legend.position = "bottom")

HomeCredit_columns_description %>% 
  filter(X1  %in% c(51:100)) %>% 
  ggplot(aes(y = X1, col = Table))+
  geom_text(aes(x = 0, label = Row), size = 2, hjust = 0)+
  geom_text(aes(x = 8, label = Description), size = 2, hjust = 0)+
  scale_x_continuous(limits = c(-0, 25))+
  theme(legend.position = "bottom")

HomeCredit_columns_description %>% 
  filter(X1  %in% c(101:150)) %>% 
  ggplot(aes(y = X1, col = Table))+
  geom_text(aes(x = 0, label = Row), size = 2, hjust = 0)+
  geom_text(aes(x = 8, label = Description), size = 2, hjust = 0)+
  scale_x_continuous(limits = c(-0, 25))+
  theme(legend.position = "bottom")

HomeCredit_columns_description %>% 
  filter(X1  %in% c(151:200)) %>% 
  ggplot(aes(y = X1, col = Table))+
  geom_text(aes(x = 0, label = Row), size = 2, hjust = 0)+
  geom_text(aes(x = 8, label = Description), size = 2, hjust = 0)+
  scale_x_continuous(limits = c(-0, 25))+
  theme(legend.position = "bottom")

HomeCredit_columns_description %>% 
  filter(X1  > 200) %>% 
  ggplot(aes(y = X1, col = Table))+
  geom_text(aes(x = 0, label = Row), size = 2, hjust = 0)+
  geom_text(aes(x = 8, label = Description), size = 2, hjust = 0)+
  scale_x_continuous(limits = c(-0, 25))+
  theme(legend.position = "bottom")
```

## Where to start?

There's a lot of data here of very different types

That means a LOT of feature engineering would be required to make good value of all of it.

Aim is to get one response per SK_ID_CURR, which could be a lot of manipulation

## How to decide?

A few options....

Start at the top?  (Only if we want to work long enough to get to the bottom)

Visualise a few things, look for some inspiration (always fun)

Look to cut out or reduce data (great if efficiency is a concern)

Apply some domain expertise/intuition about where greatest value might lie

Find some other more calculated way of assessing where most data value might lie?  (in this case, coverage?)

## Let's quickly check coverage

```{r coveragecheck_bureau}
colnames(bureau)
bureau$SK_ID_CURR %>% unique() %>% length()
colnames(bureau_balance)
bureau_summ <- bureau %>% group_by(SK_ID_CURR) %>% 
  summarise(n_IDs = unique(SK_ID_BUREAU) %>% length())
bureau_summ %>% ggplot(aes(x = 1, y = n_IDs))+geom_violin()
bureau_summ %>% ggplot(aes(x = 1, y = n_IDs))+geom_violin() +scale_y_continuous(limits = c(0,30))

TARGET <- application_train %>% select(SK_ID_CURR, TARGET)
bureau_summ <- bureau_summ %>% inner_join(TARGET, by = "SK_ID_CURR")
bureau_summ %>% ggplot(aes(x = 1, y = n_IDs, col = as.factor(TARGET)))+
  geom_violin()
  #scale_y_continuous(limits = c(0,30))

```

```{r coveragecheck_install}
colnames(installments_payments)
installments_payments$SK_ID_CURR %>% unique() %>% length()
colnames(credit_card_balance) 
credit_card_balance$SK_ID_CURR %>% unique() %>% length()
```

## Lets visualise some more anyway

```{r creditvis}
sample_med_id <- application_train$SK_ID_CURR %>% sample(20000)
credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(SK_ID_CURR %in% sample_med_id) %>% 
  ggplot(aes(x = AMT_CREDIT_LIMIT_ACTUAL, y = AMT_BALANCE, col = MONTHS_BALANCE))+
  geom_jitter(alpha = 0.6)+
  facet_grid(TARGET ~.)+
  scale_color_gradientn(colors = rainbow(10))
```



```{r creditvis2}
credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  #filter(SK_ID_CURR %in% sample_med_id) %>%
  filter(AMT_CREDIT_LIMIT_ACTUAL < 50000) %>% 
  ggplot(aes(x = AMT_CREDIT_LIMIT_ACTUAL, y = AMT_BALANCE, col = MONTHS_BALANCE))+
  geom_jitter(alpha = 0.6)+
  facet_grid(TARGET ~.)+
  scale_color_gradientn(colors = rainbow(10))
```

```{r creditvis3}
credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  #filter(SK_ID_CURR %in% sample_med_id) %>%
  #filter(AMT_CREDIT_LIMIT_ACTUAL < 50000) %>% 
  ggplot(aes( x = AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_histogram()

credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  #filter(SK_ID_CURR %in% sample_med_id) %>%
  #filter(AMT_CREDIT_LIMIT_ACTUAL < 50000) %>% 
  ggplot(aes(x = TARGET, y = AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_violin()

credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  #filter(SK_ID_CURR %in% sample_med_id) %>%
  #filter(AMT_CREDIT_LIMIT_ACTUAL < 50000) %>% 
  ggplot(aes(x = TARGET, y = AMT_BALANCE, col = as.factor(TARGET)))+
  geom_violin()
```

Could be some evidence that the defaulters have higher credit balances on average, though a weak predictor.  Can we dive deeper, to get a sense of just how much, and how granular a credit history we really have?

```{r creditgran}
sample_small_id <- credit_card_balance$SK_ID_CURR %>% sample(10)
colnames(credit_card_balance)
credit_indiv_10 <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("AMT"))
credit_indiv_10_L <- credit_indiv_10 %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

sample_small_id <- credit_card_balance$SK_ID_CURR %>% sample(10)
colnames(credit_card_balance)
credit_indiv_10 <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("AMT"))
credit_indiv_10_L <- credit_indiv_10 %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

sample_small_id <- credit_card_balance$SK_ID_CURR %>% sample(10)
colnames(credit_card_balance)
credit_indiv_10 <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("AMT"))
credit_indiv_10_L <- credit_indiv_10 %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

```

That looks pretty real. How does it compare to the number of purchases?

```{r credituse}
credit_indiv_10_amt <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("CNT"))
credit_indiv_10_amt_L <- credit_indiv_10_amt %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_amt_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

```

That cumulative repayments line is really annoying!!  Let's drop it, and have a look at the numbers as dots.

```{r withoutcum}

credit_indiv_10_amt <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("CNT")) %>% 
  select(-CNT_INSTALMENT_MATURE_CUM) 
credit_indiv_10_amt_L <- credit_indiv_10_amt %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_amt_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_point()+
  facet_grid(SK_ID_CURR~.)
         
```


##Let's check to see whether there could be any significant difference amongst defaulters


```{r creditdefaulters}
sample_small_id_T1 <- credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(TARGET == 1) %>% 
  pull(SK_ID_CURR) %>% 
  sample(10)
credit_indiv_10 <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id_T1) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("AMT"))
credit_indiv_10_L <- credit_indiv_10 %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

credit_indiv_10_amt <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id_T1) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("CNT")) %>% 
  select(-CNT_INSTALMENT_MATURE_CUM) 
credit_indiv_10_amt_L <- credit_indiv_10_amt %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_amt_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_point()+
  facet_grid(SK_ID_CURR~.)

sample_small_id_T1 <- credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(TARGET == 1) %>% 
  pull(SK_ID_CURR) %>% 
  sample(10)
credit_indiv_10 <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id_T1) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("AMT"))
credit_indiv_10_L <- credit_indiv_10 %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

credit_indiv_10_amt <- credit_card_balance %>% 
  filter(SK_ID_CURR %in% sample_small_id_T1) %>% 
  select(SK_ID_CURR, MONTHS_BALANCE, contains("CNT")) %>% 
  select(-CNT_INSTALMENT_MATURE_CUM) 
credit_indiv_10_amt_L <- credit_indiv_10_amt %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, - MONTHS_BALANCE)
credit_indiv_10_amt_L %>% 
  ggplot(aes(x = MONTHS_BALANCE, y = Value, col = Key))+
  geom_point()+
  facet_grid(SK_ID_CURR~.)

```

## What did we learn?

Hopefully inspired to figure out some good 'per applicant' summary statistics from their history.
There could be very very many from this kind of data.

Lets quickly check the missed payments on the CCs.

```{r arrearscc}

#skim(credit_card_balance)
credit_card_balance %>% 
  head(n = 50000) %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  ggplot(aes(x = SK_DPD, y = AMT_BALANCE, col = as.factor(TARGET)))+
  geom_point(alpha = 0.5)

credit_card_balance %>% 
  head(n = 50000) %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  ggplot(aes(x = SK_DPD, y = AMT_BALANCE, col = as.factor(TARGET)))+
  geom_jitter(alpha = 0.5)+
  scale_x_continuous(limits = c(0,300))+
  scale_y_continuous(limits = c(0,50000))
  
credit_card_balance %>% 
  #head(n = 50000) %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>% 
  ggplot(aes(x = SK_DPD, y = AMT_BALANCE, col = as.factor(TARGET)))+
  geom_point(alpha = 0.5)+
  scale_x_continuous(limits = c(0,300))+
  scale_y_continuous(limits = c(0,50000))
  
credit_card_balance %>% 
  #head(n = 50000) %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>% 
  ggplot(aes(x = SK_DPD, y = AMT_BALANCE-AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_point(alpha = 0.5)
  #scale_x_continuous(limits = c(0,300))+
  #scale_y_continuous(limits = c(0,50000))

credit_card_balance %>% 
  #head(n = 50000) %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>% 
  ggplot(aes(x = SK_DPD, y = AMT_BALANCE-AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_point(alpha = 0.5)+
  scale_x_continuous(limits = c(0,100))+
  scale_y_continuous(limits = c(-25000,25000))
  

```

## This looks interesting... can we violin?

```{r creditv}
credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>% 
  mutate(DPD_flag = case_when(SK_DPD > 0 ~1,
                              SK_DPD == 0 ~ 0)) %>% 
  ggplot(aes(x = 1, y = AMT_BALANCE-AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_violin()+
  scale_y_continuous(limits = c(-100000, 100000))+
  facet_grid(.~DPD_flag)
  

credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>% 
  mutate(DPD_flag = case_when(SK_DPD > 0 ~1,
                              SK_DPD == 0 ~ 0)) %>% 
  ggplot(aes(x = 1, y = AMT_BALANCE-AMT_CREDIT_LIMIT_ACTUAL, col = as.factor(TARGET)))+
  geom_violin()+
  scale_y_continuous(limits = c(-10000, 10000))+
  facet_grid(.~DPD_flag)

```

## Great signal!

But is it enough to worry about?

```{r checknums}
credit_card_balance %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(MONTHS_BALANCE > -2) %>%
  mutate(DPD_flag = case_when(SK_DPD > 0 ~1,
                              SK_DPD == 0 ~ 0)) %>%
  filter(DPD_flag == 1) %>% 
  filter(TARGET == 1) %>% 
  pull(SK_ID_CURR) %>% 
  unique() %>% 
  length()

```

## Time to actually summarise the Credit Card Data

```{r creditsumm, cache=T}
credit_card_balance_summ <- credit_card_balance %>% 
  group_by(SK_ID_CURR) %>% 
  summarise(hist.length = min(MONTHS_BALANCE),
            max.lim = max(AMT_CREDIT_LIMIT_ACTUAL),
            min.lim = min(AMT_CREDIT_LIMIT_ACTUAL),
            diff.lim = max.lim - min.lim,
            mean.bal = mean(AMT_BALANCE, na.rm = T),
            mean.count.draw = mean(CNT_DRAWINGS_CURRENT, na.rm = T),
            mean.count.ATM = mean(CNT_DRAWINGS_ATM_CURRENT, na.rm = T),
            sd.bal.med = sd(AMT_BALANCE, na.rm = T)/median(AMT_BALANCE),
            sd.bal = sd(AMT_BALANCE, na.rm = T),
            mean.count.POS = mean(CNT_DRAWINGS_POS_CURRENT, na.rm = T),
            sd.count.POS = sd(CNT_DRAWINGS_POS_CURRENT, na.rm = T),
            draw.frac = mean((AMT_BALANCE - AMT_CREDIT_LIMIT_ACTUAL+1)/(AMT_CREDIT_LIMIT_ACTUAL+1), na.rm = T),
            diff.mean = mean(AMT_BALANCE - AMT_CREDIT_LIMIT_ACTUAL, na.rm = T),
            diff.sd = sd(AMT_BALANCE - AMT_CREDIT_LIMIT_ACTUAL, na.rm = T))

credit_card_balance_summ_1 <- credit_card_balance %>% 
  filter(MONTHS_BALANCE == -1) %>% 
  group_by(SK_ID_CURR) %>% 
  summarise(DPD.1 = first(SK_DPD),
            overlim = case_when(first(AMT_BALANCE) > first(AMT_CREDIT_LIMIT_ACTUAL) ~ 1,
                                !first(AMT_BALANCE) > first(AMT_CREDIT_LIMIT_ACTUAL) ~0),
            overdue = case_when(first(SK_DPD) > 0 ~ 1,
                                !first(SK_DPD) > 0 ~ 0),
            over.lim.due = overlim*overdue,
            limdiff = first(AMT_BALANCE)-first(AMT_CREDIT_LIMIT_ACTUAL))

credit_summ_master <- credit_card_balance_summ %>% 
  left_join(credit_card_balance_summ_1, by = "SK_ID_CURR") %>% 
  mutate(has.credit.card = 1)

#credit_summ_master$SK_ID_CURR %in% application_test$SK_ID_CURR %>% sum()

skim(credit_summ_master)

credit_card_balance_summ %>% 
  filter(sd.bal.med < 10) %>% 
  ggplot(aes(x = mean.bal, y = hist.length, col = sd.bal.med))+
  geom_point(alpha = 0.6)+
  scale_color_gradientn(colors = rainbow(10))+
  facet_grid(overdue~overlim)

credit_card_balance_summ %>% 
  ggplot(aes(x = mean.bal, y = hist.length, col = sd.bal))+
  geom_point(alpha = 0.6)+
  scale_color_gradientn(colors = rainbow(10))+
  facet_grid(overdue~overlim)

```

## Visual inspection always helps, I found:

I had picked the 'max()' of a negative series

The sd() was generally proportional just to the size of the balance

the draw.frac had a bunch of infinites and non-numbers


## Time to join on the credit card data and hack again

```{r joincredit, cache=T}
application_train_train <- application_train_train %>% left_join(credit_card_balance_summ, by = "SK_ID_CURR")
application_train_test <- application_train_test %>% left_join(credit_card_balance_summ, by = "SK_ID_CURR")

# mod_rpart_3 <- rpart(data = application_train_train, formula = TARGET ~., cp = 0.0002)
# plotcp(mod_rpart_3)
# mod_rpart_3_p <- prune.rpart(mod_rpart_3, .0004)
# plotcp(mod_rpart_3_p)
# rpart.plot(mod_rpart_3_p)
# summary(mod_rpart_3_p)
```

## Is it any better?

```{r evaluaterpart3, cache=TRUE}
prediction <- predict(mod_rpart_3_p, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_3")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET_3)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET_3)
```

## Where to next?

There's still plenty on wishlist...

document flags 

occupation types and organisation types (reduce dimensions)

building types

understand relationships between previous and current ids

make a summary for all the other tables

hack some more... with xgboost?


## What about the highly cardinal values

```{r cardinals}

application_train %>% 
  ggplot(aes(x = DAYS_BIRTH, AMT_INCOME_TOTAL, col = OCCUPATION_TYPE))+
  geom_point()

application_train %>% 
  head(n = 20000) %>% 
  ggplot(aes(x = DAYS_BIRTH, AMT_INCOME_TOTAL, col = OCCUPATION_TYPE))+
  geom_point()+
  scale_y_continuous(limits = c(0, 2000000))

application_train_train %>% 
  ggplot(aes(x = OCCUPATION_TYPE))+
  geom_bar(stat = "count")+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

application_train_train %>% 
  ggplot(aes(x = ORGANIZATION_TYPE))+
  geom_bar(stat = "count")+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

application_train_train %>% 
  ggplot(aes(x = ORGANIZATION_TYPE, y = OCCUPATION_TYPE, col = as.factor(TARGET)))+
  geom_jitter()+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))


```


## We need a summary

```{r, cardinalsumm, cache=T}
cardinal_summ <- application_train %>% 
  group_by(ORGANIZATION_TYPE, OCCUPATION_TYPE) %>% 
  summarise(TARGET.mean = mean(TARGET),
            AMT_INCOME_TOTAL.mean = mean(AMT_INCOME_TOTAL),
            AMT_INCOME_TOTAL.med = median(AMT_INCOME_TOTAL),
            AMT_ANNUITY.mean = mean(AMT_INCOME_TOTAL),
            AMT_CREDIT.mean = mean(AMT_CREDIT),
            DAYS_BIRTH.mean = mean(DAYS_BIRTH),
            DAYS_EMPLOYED.mean = mean(DAYS_EMPLOYED),
            CNT_CHILDREN.mean = mean(CNT_CHILDREN),
            CNT_FAM_MEMBERS.mean = mean(CNT_FAM_MEMBERS),
            FLAG_EMP_PHONE.mean = mean(FLAG_EMP_PHONE),
            number = length(AMT_INCOME_TOTAL),
            FLAG_DOCUMENT_6.mean = mean(FLAG_DOCUMENT_6))

cardinal_summ %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = TARGET.mean, size = number))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))

cardinal_summ %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = TARGET.mean, size = log(number)))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = OCCUPATION_TYPE, size = log(number)))+
  geom_point()+
  #scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = OCCUPATION_TYPE, size = (number)))+
  geom_point()+
  #scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  #filter(str_detect(ORGANIZATION_TYPE, "Trade") == TRUE) %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = ORGANIZATION_TYPE, size = log(number)))+
  geom_point()+
  #scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  filter(str_detect(ORGANIZATION_TYPE, "type") == TRUE) %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = ORGANIZATION_TYPE, size = log(number)))+
  geom_point()+
  #scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  filter(str_detect(ORGANIZATION_TYPE, "type") == FALSE) %>% 
  ggplot(aes(x = AMT_INCOME_TOTAL.med, y = AMT_CREDIT.mean, col = ORGANIZATION_TYPE, size = log(number)))+
  geom_point()+
  #scale_color_gradientn(colours = rainbow(10))+
  scale_y_continuous(limits = c(0,1500000))+
  scale_x_continuous(limits = c(20000,300000))

cardinal_summ %>% 
  ggplot(aes(x = TARGET.mean, y = log10(number), size = (AMT_CREDIT.mean), col = OCCUPATION_TYPE))+
  geom_point()

cardinal_summ %>% 
  #filter(DAYS_BIRTH.mean)
  ggplot(aes(x = TARGET.mean, y = log10(number), size = (AMT_ANNUITY.mean), col = DAYS_BIRTH.mean))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))

cardinal_summ %>% 
  filter(DAYS_EMPLOYED.mean< 200000) %>% 
  ggplot(aes(x = TARGET.mean, y = log10(number), size = (AMT_ANNUITY.mean), col = DAYS_EMPLOYED.mean))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))

cardinal_summ %>% 
  filter(DAYS_EMPLOYED.mean< 200000) %>% 
  ggplot(aes(x = TARGET.mean, y = log10(number), size = (AMT_ANNUITY.mean), col = DAYS_EMPLOYED.mean))+
  geom_point(alpha = 0.5)+
  scale_color_gradientn(colours = rainbow(10))+
  scale_x_continuous(limits = c(0,.25))

cardinal_summ %>% 
  filter(number > 80) %>% 
  filter(DAYS_EMPLOYED.mean < 200000) %>%
  ggplot(aes(x = OCCUPATION_TYPE, y = ORGANIZATION_TYPE, size = number, col = TARGET.mean))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  theme(axis.text.x = element_text(angle = 50, hjust = 1))

```


## Now to add suitable variables

A few possibilities...

Bin it into a few categories? (How many?)

Pass the continuous variable

Omit small data-points?

```{r cardsumfeatures}

cardinal_summ <- cardinal_summ %>% 
  mutate(jobrisk = case_when(number < 80 ~ "lowdata",
                             number >= 80 & TARGET.mean < 0.05 ~ "LOW",
                             number >= 80 & TARGET.mean >=0.05 & TARGET.mean < 0.1 ~ "MED",
                             number >= 80 & TARGET.mean >=0.1 & TARGET.mean < 0.15 ~ "HIGH",
                             number >= 80 & TARGET.mean >=0.15 ~ "VHIGH"),
         oddjob = case_when(number < 50 ~ 1,
                            number >= 50 ~0))

cardinal_summ_master <- application_train %>% 
  bind_rows(application_test) %>% 
  select(-TARGET) %>% 
  left_join(cardinal_summ, by = c("OCCUPATION_TYPE", "ORGANIZATION_TYPE")) 

cardinal_summ_master <- cardinal_summ_master%>% 
  mutate(AMT_CREDIT.disp = AMT_CREDIT - AMT_ANNUITY.mean,
         AMT_ANNUITY.disp = AMT_ANNUITY- AMT_ANNUITY.mean,
         AMT_INCOME_TOTAL.disp = AMT_INCOME_TOTAL - AMT_INCOME_TOTAL.mean,
         DAYS_EMPLOYED.disp = DAYS_EMPLOYED - DAYS_BIRTH.mean,
         DAYS_BIRTH.disp = DAYS_BIRTH - DAYS_BIRTH.mean)

cardinal_summ_master <- cardinal_summ_master %>% 
  select(SK_ID_CURR, contains(".mean"), contains(".med"), contains(".disp"), jobrisk, oddjob, number)

skim(cardinal_summ_master)

application_train_train <- application_train_train %>% 
  left_join(cardinal_summ, by = c("OCCUPATION_TYPE", "ORGANIZATION_TYPE"))
application_train_test <- application_train_test %>% 
  left_join(cardinal_summ, by = c("OCCUPATION_TYPE", "ORGANIZATION_TYPE"))

application_train_train %>% glimpse()

```

## Now to see if it gets into the decision tree

```{r cardtesting, cache=T}
# mod_rpart_4 <- rpart(data = application_train_train, formula = TARGET ~., cp = 0.0002)
# plotcp(mod_rpart_4)
# summary(mod_rpart_4)
# mod_rpart_4_p <- prune.rpart(mod_rpart_4, .0003)
# plotcp(mod_rpart_4_p)
# rpart.plot(mod_rpart_4_p)
# summary(mod_rpart_4_p)

```

## Target.mean wins!.

But maybe lets check how it works in evaluation?

```{r evaluaterpart4, cache=TRUE}
prediction <- predict(mod_rpart_4, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_4")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET_4)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET_4)
```

## And the pruned version?

```{r evaluaterpart4P, cache=TRUE}
prediction <- predict(mod_rpart_4_p, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_4_P")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET_4_P)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET_4_P)
```

## Not bad! Could we reduce some data?

It's not certain that this will help, it's likely it will in a boosted model, but for a single tree, just curious.

```{r cardtestingmore, cache=T}
# mod_rpart_5 <- rpart(data = application_train_train %>% select(-ORGANIZATION_TYPE, -OCCUPATION_TYPE), formula = TARGET ~., cp = 0.0002)
# plotcp(mod_rpart_5)
# summary(mod_rpart_5)
# mod_rpart_5_p <- prune.rpart(mod_rpart_5, .00025)
# plotcp(mod_rpart_5_p)
# rpart.plot(mod_rpart_5_p)
# summary(mod_rpart_5_p)

```

But maybe lets check how it works in evaluation?

```{r evaluaterpart5, cache=TRUE}
prediction <- predict(mod_rpart_5, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_5")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET_5)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET_5)
```

## BOOM!  And the pruned version?

```{r evaluaterpart5P, cache=TRUE}
prediction <- predict(mod_rpart_5_p, newdata = application_train_test %>% select(-TARGET))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_5_P")
application_train_test <- application_train_test %>% bind_cols(prediction)
head(application_train_test$Predicted_TARGET_5_P)
roc(response = application_train_test$TARGET, predictor = application_train_test$Predicted_TARGET_5_P)
```

## That's great news!

We can derive a factor variable with five levels and a continuous variable which outperforms two variables with high cardinality.  

```{r xgboost1, cache=T}

application_train_train <- application_train_train %>% select(-sd.bal.med)
application_train_test <- application_train_test %>% select(-sd.bal.med)
application_train_train[is.na(application_train_train)] <- -10000000
application_train_test[is.na(application_train_test)] <- -10000000
application_train_train <- application_train_train %>% filter(!number == -10000000)
application_train_test <- application_train_test %>% filter(!number == -10000000)


### Without the highly cardinal features
 train <- list(sparse.model.matrix(~., data = application_train_train %>% select(-TARGET,  -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>%  filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave")), application_train_train %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>%  pull(TARGET))
 names(train) <- c("data", "label")
 test <- list(sparse.model.matrix( ~ ., data = application_train_test %>% select(-TARGET, -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave")), application_train_test %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>%  pull(TARGET))
 names(test) <- c("data", "label")
 
 ### potential problem vars
 # - NAME_FAMILY_STATUS, - NAME_INCOME_TYPE, -OWN_CAR_AGE,
 
 
### Including the cardinals
 #  train <- list(sparse.model.matrix(~., data = application_train_train %>% select(-TARGET, -OWN_CAR_AGE,  -contains("Predicted_TARGET"))), application_train_train$TARGET)
 # names(train) <- c("data", "label")
 # test <- list(sparse.model.matrix( ~ ., data = application_train_test %>% select(-TARGET, - OWN_CAR_AGE, -.,  -contains("Predicted_TARGET"))), application_train_test$TARGET)
 # names(test) <- c("data", "label")
 
# checker <- tibble()
#  for(i in colnames(application_train_train %>% select(-TARGET))){
#    print(i)
#    train <- list(sparse.model.matrix(~., data = application_train_train %>% select(i, checker$i, TARGET)), application_train_train$TARGET)
# adder <- tibble(i)
#    checker <- checker %>% bind_rows(adder)
#  }

#colnames(application_train_train) %in% checker$i
 
## heaps of testing to debug all the matrix objects
 testvec <- colnames(application_train_train) %in% colnames(application_train_test) %>% tibble()
 colnames(testvec) <- c("included")
 namesvec <- colnames(application_train_train) %>% tibble()
 colnames(namesvec) <- c("names")
testvec <- testvec %>% bind_cols(namesvec)
testvec %>% filter(included == F) %>% print()

# application_train_train %>% select(-TARGET, -OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique() == application_train_test %>% select(-TARGET, - OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique()
# 
 train[["data"]]@Dimnames[[2]] %in%  test[["data"]]@Dimnames[[2]] 
 test[["data"]]@Dimnames[[2]] %in% train[["data"]]@Dimnames[[2]]   #%>% unique()
 
#  NAME_INCOME_TYPEPensioner , NAME_FAMILY_STATUSUnknown, NAME_INCOME_TYPE != "Maternity leave"
# strange <-  application_train_test %>% filter(jobrisk == "-1e+07") 
# 
# strange %>% ggplot(aes(x = AMT_INCOME_TOTAL, y = AMT_CREDIT, col = number))+
#   geom_point()
# 
# strange %>% ggplot(aes(x = ORGANIZATION_TYPE, y = OCCUPATION_TYPE, col = number))+
#   geom_point()+
#   theme(axis.text.x = element_text(angle = 60))
#  
 
 dtrain <- xgb.DMatrix(data = train$data, label=train$label)
 dtest <- xgb.DMatrix(data = test$data, label=test$label)
 watchlist <- list(train=dtrain, test=dtest)
#
 #mod_xgb_lin <- xgb.train(data = dtrain, booster = "gblinear",  nrounds = 50, watchlist = watchlist)
 mod_xgb_tree <- xgb.train(data = dtrain,  booster = "gbtree", eta = .1, nrounds = 65, watchlist = watchlist)

 
prediction <- predict(mod_xgb_tree, test$data) %>% tibble()
colnames(prediction) <- c("Predicted_TARGET_xgb_tree")
application_train_test.ass <- application_train_test %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>% bind_cols(prediction)
head(application_train_test.ass$Predicted_TARGET_xgb_tree)
roc(response = application_train_test.ass$TARGET, predictor = prediction$Predicted_TARGET_xgb_tree)

imp <- xgb.importance(model = mod_xgb_tree)
imp %>% 
  filter((Gain) > .0065, (Cover > .0065)) %>% 
  ggplot(aes(x = log(Gain), y = log(Cover), col = (Frequency)))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  geom_text(aes(label = Feature))

# imp %>% 
#   filter((Gain) > .0065, (Cover > .0065)) %>% 
#   ggplot(aes(x = (Gain), y = (Cover), col = (Frequency)))+
#   geom_point()+
#   scale_color_gradientn(colours = rainbow(10))
 
# prediction <- predict(mod_xgb_lin, test$data) %>% tibble()
# colnames(prediction) <- c("Predicted_TARGET_xgb_lin")
# application_train_test <- application_train_test %>% bind_cols(prediction)
# head(application_train_test$Predicted_TARGET_xgb_lin)
# roc(response = application_train_test$TARGET, predictor = prediction$Predicted_TARGET_xgb_lin)
#  


```

How about we quickly explore the payments data

```{r explorpayments}
installments_payments %>% colnames()
installments_payments %>% skim()
currentids <- installments_payments$SK_ID_CURR %>% unique()
pastids <- installments_payments$SK_ID_PREV %>% unique()

pastids %in% currentids %>% sum()

currentids %>% length()
pastids %>% length()

# installments_payments %>% 
#   head(n = 2000000) %>% 
#   ggplot(aes(x = SK_ID_PREV, y = SK_ID_CURR, col = as.numeric(NUM_INSTALMENT_NUMBER)))+
#   geom_point() +
#   scale_colour_gradientn(colours = rainbow(10))

installments_payments %>% 
  head(n = 1000000) %>% 
  ggplot(aes(x = DAYS_INSTALMENT, y = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT, col = NUM_INSTALMENT_NUMBER))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))

installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  head(n = 1000000) %>%
  ggplot(aes(x = DAYS_INSTALMENT, y = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT, col = NUM_INSTALMENT_NUMBER))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(.~TARGET)

installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  head(n = 1000000) %>%
  ggplot(aes(x = DAYS_INSTALMENT, y = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT, col = NUM_INSTALMENT_NUMBER))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(.~TARGET)

installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  head(n = 100000) %>%
  ggplot(aes(x = AMT_INSTALMENT, y = AMT_PAYMENT , col = DAYS_INSTALMENT))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(.~TARGET)+
  scale_x_continuous(limits = c(-10000,800000))+
  scale_y_continuous(limits = c(-10000,800000))
  
installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  head(n = 100000) %>%
  ggplot(aes(x = AMT_INSTALMENT, y = AMT_PAYMENT , col = DAYS_INSTALMENT))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(.~TARGET)+
  scale_x_continuous(limits = c(-10000,80000))+
  scale_y_continuous(limits = c(-10000,80000))
  
installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  head(n = 100000) %>%
  ggplot(aes(x = AMT_INSTALMENT, y = AMT_PAYMENT , col = DAYS_INSTALMENT))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(.~TARGET)+
  scale_x_continuous(limits = c(-1000,8000))+
  scale_y_continuous(limits = c(-1000,8000))
  

```

It looks like there's a group of people who will pay off their loan in an installment, perhaps when it's close to being done.  And another group who tend to to pay a bit extra.  And the majority pay exactly the right amount, and a few not enough.  ALso people tend to be only a bit early, but can be quite late. I wonder how these two overlap.

```{r moreinstallments}
installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  head(n = 1000000) %>% 
  ggplot(aes(x = DAYS.diff, y = AMT.diff, col = DAYS_INSTALMENT))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
    scale_x_continuous(limits = c(-100,100))+
  scale_y_continuous(limits = c(-100000,200000))+
  facet_grid(TARGET~.)

installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(DAYS_INSTALMENT > -100) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  head(n = 1000000) %>% 
  ggplot(aes(x = DAYS.diff, y = AMT.diff, col = DAYS_INSTALMENT))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
    scale_x_continuous(limits = c(-100,100))+
  scale_y_continuous(limits = c(-100000,200000))+
  facet_grid(TARGET~.)


```

Still not a lot of clarity here.   Perhaps we should look at some individual credit records to see, with time along the x axis.

```{r installmentsindiv}
sample_small_id <- installments_payments$SK_ID_CURR %>% sample(10)

installments_long_samp <- installments_payments %>% 
  filter(SK_ID_CURR %in% sample_small_id) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, -SK_ID_PREV, -NUM_INSTALMENT_VERSION, -NUM_INSTALMENT_NUMBER, -DAYS_INSTALMENT)


installments_long_samp %>% 
  filter(!Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_point()+
  facet_grid(SK_ID_CURR~.)

installments_long_samp %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = DAYS_INSTALMENT, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

installments_long_samp %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

sample_small_id_T1 <- installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(TARGET == 1) %>% 
  pull(SK_ID_CURR) %>% 
  sample(10)

installments_long_samp_T <- installments_payments %>% 
  filter(SK_ID_CURR %in% sample_small_id_T1) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, -SK_ID_PREV, -NUM_INSTALMENT_VERSION, -NUM_INSTALMENT_NUMBER, -DAYS_INSTALMENT)


installments_long_samp_T %>% 
  filter(!Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = as.factor(SK_ID_PREV)))+
  geom_point()+
  facet_grid(SK_ID_CURR~.)

installments_long_samp_T %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = DAYS_INSTALMENT, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

installments_long_samp_T %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_CURR~.)

# installments_long_samp_T %>% 
#   group_by(SK_ID_CURR) %>% 
#   pull(SK_ID_PREV) %>% 
#   unique()



```


Let's look at individual loan products

```{r installmentsindiv2}
sample_small_id <- installments_payments$SK_ID_PREV %>% sample(10)

installments_long_samp <- installments_payments %>% 
  filter(SK_ID_PREV %in% sample_small_id) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  gather(key = "Key", value = "Value", -SK_ID_CURR, -SK_ID_PREV, -NUM_INSTALMENT_VERSION, -NUM_INSTALMENT_NUMBER, -DAYS_INSTALMENT)


installments_long_samp %>% 
  filter(!Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_point()+
  facet_grid(SK_ID_PREV~.)

installments_long_samp %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = DAYS_INSTALMENT, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_PREV~.)

installments_long_samp %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_PREV~.)

sample_small_id_T1 <- installments_payments %>% 
  inner_join(TARGET, by = "SK_ID_CURR") %>% 
  filter(TARGET == 1) %>% 
  pull(SK_ID_PREV) %>% 
  sample(10)

installments_long_samp_T <- installments_payments %>% 
  filter(SK_ID_PREV %in% sample_small_id_T1) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>% 
  gather(key = "Key", value = "Value", -SK_ID_PREV, -SK_ID_PREV, -NUM_INSTALMENT_VERSION, -NUM_INSTALMENT_NUMBER, -DAYS_INSTALMENT)


installments_long_samp_T %>% 
  filter(!Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT", "SK_ID_CURR")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = as.factor(Key)))+
  geom_point()+
  facet_grid(SK_ID_PREV~.)

installments_long_samp_T %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = DAYS_INSTALMENT, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_PREV~.)

installments_long_samp_T %>% 
  filter(Key %in% c("AMT_PAYMENT", "AMT.diff", "AMT_INSTALMENT")) %>% 
  ggplot(aes(x = NUM_INSTALMENT_NUMBER, y = Value, col = Key))+
  geom_line()+
  facet_grid(SK_ID_PREV~.)

# installments_long_samp_T %>% 
#   group_by(SK_ID_PREV) %>% 
#   pull(SK_ID_PREV) %>% 
#   unique()

```

Need to do summaries of each loan product (SK_ID_PREV), then for each SK_ID_CURR.

```{r installmentssummaries_prev}
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

installments_summ_prev <- installments_payments %>%
  #head(n = 500000) %>% 
  left_join(application_train, by = "SK_ID_CURR") %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT) %>%
  mutate(AMT_INSTALMENT.rel.income = AMT_INSTALMENT/(AMT_INCOME_TOTAL+1)) %>% 
  group_by(SK_ID_PREV) %>% 
  summarise(AMT_PAYMENT.mean = mean(AMT_PAYMENT, na.rm = T),
            AMT_PAYMENT.sd = sd(AMT_PAYMENT, na.rm = T),
            PAYMENT.last = max(DAYS_ENTRY_PAYMENT),
            LOAN.length = max(DAYS_INSTALMENT) - min(DAYS_INSTALMENT),
            AMT_INSTALMENT.rel.income = mean(AMT_INSTALMENT.rel.income, na.rm = T),
            AMT.diff.mean = mean(AMT.diff, na.rm = T),
            DAYS.diff.mean = mean(AMT.diff, na.rm = T),
            AMT.diff.max = max(AMT.diff, na.rm = T),
            DAYS.diff.max = max(AMT.diff, na.rm = T),
            AMT.diff.min = min(AMT.diff, na.rm = T),
            DAYS.diff.min = min(AMT.diff, na.rm = T),
            AMT.diff.sd = sd(AMT.diff, na.rm = T),
            INSTALMENT.rel.sd = sd(AMT_INSTALMENT.rel.income, na.rm = T),
            DAYS.diff.sd = sd(DAYS.diff, na.rm = T),
            AMT.diff.rel.income = mean(AMT.diff/(AMT_INCOME_TOTAL+1), na.rm = T),
            DAYS.diff.rel.employed = mean(DAYS.diff/(DAYS_EMPLOYED +1), na.rm = T),
            LOAN.length.rel.employed = mean(LOAN.length/DAYS_EMPLOYED, na.rm = T))



installments_summ_prev_flow <- installments_payments %>% 
  left_join(installments_summ_prev, by = "SK_ID_PREV") %>% 
  #head(n = 500000) %>% 
  group_by(SK_ID_PREV) %>% 
  arrange(DAYS_INSTALMENT) %>% 
  mutate(AMT.diff = AMT_PAYMENT - AMT_INSTALMENT,
         DAYS.diff = DAYS_ENTRY_PAYMENT - DAYS_INSTALMENT,
         AMT_PAYMENT.step = AMT_PAYMENT - lag(AMT_PAYMENT),
         AMT.diff.step = AMT.diff - lag(AMT.diff),
         DAYS.diff.step = DAYS.diff - lag(DAYS.diff)) %>% 
  summarise(AMT_PAYMENT.grad = mean(AMT_PAYMENT.step, na.rm = T),
            AMT_PAYMENT.grad.sign = Mode(sign(AMT_PAYMENT.step)),
            AMT.diff.grad = mean(AMT.diff.step, na.rm = T),
            AMT.diff.grad.sign = Mode(sign(AMT.diff.step)),
            DAYS.diff.grad = mean(DAYS.diff.step, na.rm = T),
            DAYS.diff.grad.sign = Mode(sign(DAYS.diff.step)),
            AMT_PAYMENT.step.last = last(AMT_PAYMENT.step))

installments_summ_prev <- installments_summ_prev %>% 
  left_join(installments_summ_prev_flow, by = "SK_ID_PREV")

#skim(installments_summ_prev)

# installments_summ_prev %>% 
#   left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>% 
#   left_join(TARGET, by = "SK_ID_CURR") %>% 
#   ggplot(aes(x = AMT.diff.grad, y = AMT_INSTALMENT.rel.income, col = AMT_PAYMENT.mean ))+
#   geom_point()+
#   scale_color_gradientn(colours = rainbow(10))+
#   facet_grid(TARGET~DAYS.diff.grad.sign)

```

Still nothing obvious, maybe see what rpart has to say?

```{r installtestingmore, cache=T}
install_trainset <- installments_summ_prev$SK_ID_PREV %>% unique() %>% sample(140000)

install_train <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>% 
  filter(SK_ID_PREV %in% install_trainset) %>% 
  left_join(TARGET, by = "SK_ID_CURR") 

install_test <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>% 
  filter(!SK_ID_PREV %in% install_trainset) %>% 
  left_join(TARGET, by = "SK_ID_CURR") 

mod_rpart_install <- rpart(data = install_train %>% select(-SK_ID_CURR, - SK_ID_PREV), formula = TARGET ~., cp = 0.0005)
plotcp(mod_rpart_install)
summary(mod_rpart_install)


```

```{r evaluaterpartinstall, cache=TRUE}
prediction <- predict(mod_rpart_install, newdata = install_test %>% select(-TARGET, - SK_ID_PREV, - SK_ID_CURR))
prediction <- prediction %>% data.frame()
colnames(prediction) <- c("Predicted_TARGET_INS2")
install_test <- install_test %>% bind_cols(prediction)
head(install_test$Predicted_TARGET_INS2)
roc(response = install_test$TARGET, predictor = install_test$Predicted_TARGET_INS2)
```

So it appears that we can get some slight predictive power (very slight) from individual loans.

Time to build a summary for the individual loan applicant. 

Maybe first just check to see how many loans most people have had?

```{r instalchecksum}

installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>%
  group_by(SK_ID_CURR) %>% 
  summarise(loans = length(unique(SK_ID_PREV))) %>% 
  ggplot(aes(x = loans))+
  geom_histogram(binwidth = 1)
  

```


```{r finalinstallsumm}

#skim(installments_summ_prev)

installments_summ_index_last <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>%
  group_by(SK_ID_CURR) %>% 
  arrange((PAYMENT.last)) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))

installments_summ_index_payment <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>%
  group_by(SK_ID_CURR) %>% 
  arrange((AMT_PAYMENT.mean)) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))

installments_summ_index_length <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>%
  group_by(SK_ID_CURR) %>% 
  arrange((LOAN.length)) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))

installments_summ_index_short <- installments_summ_prev %>% 
  left_join(installments_payments %>% select(SK_ID_CURR, SK_ID_PREV), by = "SK_ID_PREV") %>%
  group_by(SK_ID_CURR) %>% 
  arrange(desc(LOAN.length)) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))

# testvector <- colnames(installments_summ_prev)
# 
# testvector <- testvector %>% paste0("tester",.)

# installments_summ_prev %>%
#   filter(SK_ID_PREV %in% installments_summ_index_length$SK_ID_PREV) %>% 
#   summarise(payment = mean(LOAN.length))

installments_summ_index_last$SK_ID_PREV %in% installments_summ_index_length$SK_ID_PREV %>% sum()
installments_summ_index_payment$SK_ID_PREV %in% installments_summ_index_short$SK_ID_PREV %>% sum()

SK_KEY <- installments_payments %>% 
  group_by(SK_ID_PREV) %>% 
  summarise(SK_ID_CURR = first(SK_ID_CURR))

installments_summ_prev <- installments_summ_prev %>% 
  left_join(SK_KEY, by = "SK_ID_PREV")

installments_summ_last <- installments_summ_prev %>% 
  filter(SK_ID_PREV %in% installments_summ_index_last$SK_ID_PREV) %>% 
  select(-SK_ID_PREV)
colnames(installments_summ_last) <- colnames(installments_summ_last) %>% paste0(.,".last")
colnames(installments_summ_last)[25] <- "SK_ID_CURR"

installments_summ_payment <- installments_summ_prev %>% 
  filter(SK_ID_PREV %in% installments_summ_index_payment$SK_ID_PREV) %>% 
  select(-SK_ID_PREV)
colnames(installments_summ_payment) <- colnames(installments_summ_payment) %>% paste0(.,".payment")
colnames(installments_summ_payment)[25] <- "SK_ID_CURR"

installments_summ_length <- installments_summ_prev %>% 
  filter(SK_ID_PREV %in% installments_summ_index_length$SK_ID_PREV) %>% 
  select(-SK_ID_PREV)
colnames(installments_summ_length) <- colnames(installments_summ_length) %>% paste0(.,".length")
colnames(installments_summ_length)[25] <- "SK_ID_CURR"

installments_summ_length$SK_ID_PREV %>% unique() %>% length()

installments_summ_short <- installments_summ_prev %>% 
  filter(SK_ID_PREV %in% installments_summ_index_short$SK_ID_PREV) %>% 
  select(-SK_ID_PREV)
colnames(installments_summ_short) <- colnames(installments_summ_short) %>% paste0(.,".short")
colnames(installments_summ_short)[25] <- "SK_ID_CURR"

loan_count <- installments_summ_prev %>% 
  group_by(SK_ID_CURR) %>% 
  summarise(NUMBER_LOANS_install = SK_ID_PREV %>% unique() %>% length())

glimpse(loan_count)

installments_summ_master <- installments_summ_last %>% 
  left_join(installments_summ_length, by = "SK_ID_CURR") %>% 
  left_join(installments_summ_payment, by = "SK_ID_CURR") %>% 
  left_join(installments_summ_short, by = "SK_ID_CURR") %>% 
  left_join(loan_count, by = "SK_ID_CURR") 
```

```{r xgbinstall}

application_train_train. <- application_train_train %>% 
  left_join(installments_summ_master, by = "SK_ID_CURR")

application_train_test. <- application_train_test %>% 
  left_join(installments_summ_master, by = "SK_ID_CURR")

skim(application_train_train.)

application_train_train.[is.na(application_train_train.)] <- -10000000
application_train_test.[is.na(application_train_test.)] <- -10000000

### Without the highly cardinal features
 train <- list(sparse.model.matrix(~., data = application_train_train. %>% select(-TARGET,  -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>%  filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave")), application_train_train. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>%  pull(TARGET))
 names(train) <- c("data", "label")
 test <- list(sparse.model.matrix( ~ ., data = application_train_test. %>% select(-TARGET, -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave")), application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>% pull(TARGET))
 names(test) <- c("data", "label")
 
 ### potential problem vars
 # - NAME_FAMILY_STATUS, - NAME_INCOME_TYPE, -OWN_CAR_AGE,

# application_train_train %>% select(-TARGET, -OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique() == application_train_test %>% select(-TARGET, - OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique()
# 
 train[["data"]]@Dimnames[[2]] %in%  test[["data"]]@Dimnames[[2]]  #%>% unique()
 
 
 dtrain <- xgb.DMatrix(data = train$data, label=train$label)
 dtest <- xgb.DMatrix(data = test$data, label=test$label)
 watchlist <- list(train=dtrain, test=dtest)
#
 #mod_xgb_lin <- xgb.train(data = dtrain, booster = "gblinear",  nrounds = 50, watchlist = watchlist)
 mod_xgb_tree_inst <- xgb.train(data = dtrain,  booster = "gbtree", eta = .05, nrounds = 300, watchlist = watchlist)

 
prediction <- predict(mod_xgb_tree_inst, test$data) %>% tibble()
colnames(prediction) <- c("Predicted_TARGET_xgb_tree_inst")
application_train_test.ass <- application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>% bind_cols(prediction)
head(application_train_test.ass$Predicted_TARGET_xgb_tree_inst)
roc(response = application_train_test.ass$TARGET, predictor = prediction$Predicted_TARGET_xgb_tree_inst)

imp <- xgb.importance(model = mod_xgb_tree_inst)
imp %>% 
  filter((Gain) > .0035, (Cover > .0035)) %>% 
  ggplot(aes(x = log(Gain), y = log(Cover), col = (Frequency)))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  geom_text(aes(label = Feature))




```

So it looks as though we've got another percent or so from the installation data.

What's next?

Probably the previous applications...

```{r previousexplore}

colnames(previous_application) %in% colnames(application_train)

colnames(previous_application)[c(2:4, 6, 8:10, 21)]

previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>% 
  ggplot(aes(x = CODE_REJECT_REASON, y = AMT_APPLICATION, col = DAYS_DECISION))+
  geom_jitter()+
  scale_color_gradientn(colours = rainbow(10))+
  facet_grid(TARGET~.)

previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  ggplot(aes(x = CODE_REJECT_REASON))+
  geom_histogram(stat = "count")+
  facet_grid(TARGET~.)


previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  filter(CODE_REJECT_REASON %in% c("SCO", "LIMIT", "HC", "XNA")) %>% 
  ggplot(aes(x = CODE_REJECT_REASON, y = DAYS_DECISION, col = CODE_REJECT_REASON))+
  geom_violin()+
  facet_grid(TARGET~.)+
  scale_y_continuous(limits = c(-500,0))

```

There's quite a group of defaulters who applied and got recection reason XNA exactly one year ago, or just after. 

```{r moreprevviolins}

previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL), by = "SK_ID_CURR") %>% 
  filter(CODE_REJECT_REASON %in% c("SCO", "LIMIT", "HC", "XNA")) %>% 
  ggplot(aes(x = CODE_REJECT_REASON, y = AMT_DOWN_PAYMENT/AMT_INCOME_TOTAL, col = CODE_REJECT_REASON))+
  geom_violin()+
  facet_grid(TARGET~.)+
  scale_y_continuous(limits = c(0,.02))

previous_application %>% 
  ggplot(aes(x = AMT_DOWN_PAYMENT/AMT_APPLICATION, y = AMT_CREDIT, col = AMT_APPLICATION))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))

previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  filter(AMT_CREDIT < 150000) %>% 
  ggplot(aes(x = AMT_DOWN_PAYMENT/AMT_APPLICATION, y = AMT_CREDIT, col = AMT_GOODS_PRICE))+
  geom_point(alpha = 0.5)+
  scale_colour_gradientn(colours = rainbow(10))+
  facet_grid(TARGET~.)


```

```{r morecardinals}
previous_application$PRODUCT_COMBINATION %>% unique()
previous_application$NAME_SELLER_INDUSTRY %>% unique()
previous_application$NAME_GOODS_CATEGORY %>% unique()
previous_application$NAME_CASH_LOAN_PURPOSE %>% unique()

prev_app_summ <-previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  filter(SK_ID_CURR %in% application_train_train$SK_ID_CURR) %>% 
  group_by(PRODUCT_COMBINATION, NAME_SELLER_INDUSTRY) %>% 
  summarise(AMT_APPLICATION = mean(AMT_APPLICATION),
            DAYS_DECISION = mean(DAYS_DECISION),
            TARGET.mean.2 = mean(TARGET, na.rm = T),
            number = n())

prev_app_summ %>% 
  filter(number > 50) %>% 
  ggplot(aes(x = PRODUCT_COMBINATION, y = NAME_SELLER_INDUSTRY, size = number, col = DAYS_DECISION))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

prev_app_summ %>% 
  filter(number > 100) %>% 
  ggplot(aes(x = PRODUCT_COMBINATION, y = NAME_SELLER_INDUSTRY, size = number, col = TARGET.mean.2))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

prev_app_summ2 <- previous_application %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>%
  filter(SK_ID_CURR %in% application_train_train$SK_ID_CURR) %>% 
  group_by(NAME_GOODS_CATEGORY, NAME_CASH_LOAN_PURPOSE) %>% 
  summarise(AMT_APPLICATION = mean(AMT_APPLICATION),
            DAYS_DECISION = mean(DAYS_DECISION),
            TARGET.mean.3 = mean(TARGET, na.rm = T),
            number = n())

prev_app_summ2 %>% 
  filter(number > 50) %>% 
  ggplot(aes(x = NAME_GOODS_CATEGORY, y = NAME_CASH_LOAN_PURPOSE, size = number, col = DAYS_DECISION))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

prev_app_summ2 %>% 
  filter(number > 1000) %>% 
  ggplot(aes(x = NAME_GOODS_CATEGORY, y = NAME_CASH_LOAN_PURPOSE, size = number, col = TARGET.mean.3))+
  geom_point()+
  scale_colour_gradientn(colours = rainbow(10))+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

```

Looks like it's time to put together a summary. 

```{r summarisingprevapp}

previous_application$SK_ID_CURR %>% unique() %>% length()

prev_app_summ_index_amt <- previous_application %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(AMT_APPLICATION) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))
  
previous_summ_amt <- previous_application %>% 
  filter(SK_ID_PREV %in% prev_app_summ_index_amt$SK_ID_PREV) %>% 
  select(-SK_ID_PREV) %>% 
  mutate(yearout = (DAYS_DECISION+365)^2)
previous_summ_amt <- previous_summ_amt %>% 
  left_join(prev_app_summ %>% select(PRODUCT_COMBINATION, NAME_SELLER_INDUSTRY, TARGET.mean.2), by = c("PRODUCT_COMBINATION", "NAME_SELLER_INDUSTRY")) %>% 
  left_join(prev_app_summ2 %>% select(NAME_GOODS_CATEGORY, NAME_CASH_LOAN_PURPOSE, TARGET.mean.3), by = c("NAME_GOODS_CATEGORY", "NAME_CASH_LOAN_PURPOSE"))
colnames(previous_summ_amt) <- colnames(previous_summ_amt) %>% paste0(.,".app")
colnames(previous_summ_amt)[1] <- "SK_ID_CURR"
  
prev_app_summ_index_dec <- previous_application %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(DAYS_DECISION) %>% 
  summarise(SK_ID_PREV = last(SK_ID_PREV))

previous_summ_dec <- previous_application %>% 
  filter(SK_ID_PREV %in% prev_app_summ_index_dec$SK_ID_PREV) %>% 
  select(-SK_ID_PREV) %>% 
  mutate(yearout = (DAYS_DECISION+365)^2)
previous_summ_dec <- previous_summ_dec %>% 
  left_join(prev_app_summ %>% select(PRODUCT_COMBINATION, NAME_SELLER_INDUSTRY, TARGET.mean.2), by = c("PRODUCT_COMBINATION", "NAME_SELLER_INDUSTRY")) %>% 
  left_join(prev_app_summ2 %>% select(NAME_GOODS_CATEGORY, NAME_CASH_LOAN_PURPOSE, TARGET.mean.3), by = c("NAME_GOODS_CATEGORY", "NAME_CASH_LOAN_PURPOSE"))
colnames(previous_summ_dec) <- colnames(previous_summ_dec) %>% paste0(.,".dec")
colnames(previous_summ_dec)[1] <- "SK_ID_CURR"

colnames(previous_application)[c(2:4, 6, 8:10, 21)]

previous_summ_summ <- previous_application %>% 
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL), by = "SK_ID_CURR") %>% 
  group_by(SK_ID_CURR) %>% 
  summarise(DAYS_DECISION.mean = mean(DAYS_DECISION, na.rm = T),
            DAYS_DECISION.sd = sd(DAYS_DECISION, na.rm = T),
            CODE_REJECT_REASON.mode = Mode(CODE_REJECT_REASON),
            AMT_APPLICATION.mean = mean(AMT_APPLICATION, na.rm = T),
            AMT_APPLICATION.sd = sd(AMT_APPLICATION, na.rm = T),
            DAYS_DECISION.365 = mean(DAYS_DECISION, na.rm = T) + 365,
            DAYS_DECISION.365.sq = (mean(DAYS_DECISION, na.rm = T) + 365)^2,
            DAYS_DECISION.365.over = case_when(mean(DAYS_DECISION) <= -365 & mean(DAYS_DECISION) >= -396 ~1),
            NFLAG_INSURED_ON_APPROVAL.mode = Mode(NFLAG_INSURED_ON_APPROVAL),
            AMT_DOWN_PAYMENT_AMT_APPLICATION.mean = mean(AMT_DOWN_PAYMENT/AMT_APPLICATION, na.rm = T),
            RATIO.mean = mean(AMT_APPLICATION/AMT_INCOME_TOTAL, na.rm = T),
            RATIO.sd = sd(AMT_APPLICATION/AMT_INCOME_TOTAL, na.rm = T))



```

```{r joinprevious}
previous_summ_master <- previous_summ_summ %>% 
  left_join(previous_summ_amt, by = "SK_ID_CURR") %>% 
  left_join(previous_summ_dec, by = "SK_ID_CURR")

previous_summ_master <- previous_summ_master %>% 
  select(-contains("PRODUCT_COMBINATION"), -contains("NAME_SELLER_INDUSTRY"), -contains("NAME_GOODS_CATEGORY"), -contains("NAME_CASH_LOAN_PURPOSE"))

```

Time to put together what we've found from the previous application data and join it with the previous application training set

```{r xgbwithprevious}

# application_train_train <- application_train_train.
# application_train_test <- application_train_test.


application_train_train. <- application_train_train %>% 
  left_join(previous_summ_master, by = "SK_ID_CURR")

application_train_test. <- application_train_test %>% 
  left_join(previous_summ_master, by = "SK_ID_CURR")

skim(application_train_train.)

application_train_train. <- application_train_train. %>% 
  mutate(EXT_23_diff = EXT_SOURCE_2 - EXT_SOURCE_3,
         EXT_12_diff = EXT_SOURCE_1 - EXT_SOURCE_2,
         EXT_13_diff = EXT_SOURCE_1 - EXT_SOURCE_3,
         EXT_23_diff_sq = (EXT_SOURCE_2 - EXT_SOURCE_3)^2,
         EXT_12_diff_sq = (EXT_SOURCE_1 - EXT_SOURCE_2)^2,
         EXT_13_diff_sq = (EXT_SOURCE_1 - EXT_SOURCE_3)^2,
         EXT_23_sum = EXT_SOURCE_2 + EXT_SOURCE_3,
         EXT_12_sum = EXT_SOURCE_1 + EXT_SOURCE_2,
         EXT_13_sum = EXT_SOURCE_1 + EXT_SOURCE_3)

application_train_test. <- application_train_test. %>% 
  mutate(EXT_23_diff = EXT_SOURCE_2 - EXT_SOURCE_3,
         EXT_12_diff = EXT_SOURCE_1 - EXT_SOURCE_2,
         EXT_13_diff = EXT_SOURCE_1 - EXT_SOURCE_3,
         EXT_23_diff_sq = (EXT_SOURCE_2 - EXT_SOURCE_3)^2,
         EXT_12_diff_sq = (EXT_SOURCE_1 - EXT_SOURCE_2)^2,
         EXT_13_diff_sq = (EXT_SOURCE_1 - EXT_SOURCE_3)^2,
         EXT_23_sum = EXT_SOURCE_2 + EXT_SOURCE_3,
         EXT_12_sum = EXT_SOURCE_1 + EXT_SOURCE_2,
         EXT_13_sum = EXT_SOURCE_1 + EXT_SOURCE_3)

application_train_train.[is.na(application_train_train.)] <- -10000000
application_train_test.[is.na(application_train_test.)] <- -10000000

### Without the highly cardinal features
 train <- list(sparse.model.matrix(~., data = application_train_train. %>% select(-SK_ID_CURR, -TARGET,  -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>%  filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA")), application_train_train. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA") %>%  pull(TARGET))
 names(train) <- c("data", "label")
 test <- list(sparse.model.matrix( ~ ., data = application_train_test. %>% select(-SK_ID_CURR, -TARGET, -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA")), application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA") %>%  pull(TARGET))
 names(test) <- c("data", "label")
 
 ### potential problem vars
 # - NAME_FAMILY_STATUS, - NAME_INCOME_TYPE, -OWN_CAR_AGE, NAME_CONTRACT_TYPE != "appXNA"

# application_train_train %>% select(-TARGET, -OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique() == application_train_test %>% select(-TARGET, - OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique()
# 
train[["data"]]@Dimnames[[2]] %in% test[["data"]]@Dimnames[[2]] #%>% unique()
 test[["data"]]@Dimnames[[2]] %in% train[["data"]]@Dimnames[[2]] 


 
 dtrain <- xgb.DMatrix(data = train$data, label=train$label)
 dtest <- xgb.DMatrix(data = test$data, label=test$label)
 watchlist <- list(train=dtrain, test=dtest)
#
 #mod_xgb_lin <- xgb.train(data = dtrain, booster = "gblinear",  nrounds = 50, watchlist = watchlist)
 mod_xgb_tree_inst <- xgb.train(data = dtrain,  booster = "gbtree", eta = .1, nrounds = 300, watchlist = watchlist)

 
prediction <- predict(mod_xgb_tree_inst, test$data) %>% tibble()
colnames(prediction) <- c("Predicted_TARGET_xgb_tree_inst_prev")
application_train_test.ass <- application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>%  bind_cols(prediction)
head(application_train_test.ass$Predicted_TARGET_xgb_tree_inst)
roc(response = application_train_test.ass$TARGET, predictor = prediction$Predicted_TARGET_xgb_tree_inst_prev)

imp <- xgb.importance(model = mod_xgb_tree_inst)
imp %>% 
  filter((Gain) > .0035, (Cover > .0035)) %>% 
  ggplot(aes(x = log(Gain), y = log(Cover), col = (Frequency)))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  geom_text(aes(label = Feature))


```

perhaps let's see whether we can see which features are more significant with a simple linear model

```{r linmodels}

lm_app <- application_train_train. %>% select(-SK_ID_CURR) %>% lm(formula = TARGET ~.)

summary_lm <- lm_app %>% summary()

coefs <- summary_lm[["coefficients"]] %>% data.frame()

coefs <- data.frame(names = row.names(coefs), coefs)
rownames(coefs) <- NULL
colnames(coefs)
coefs <- coefs %>% 
  mutate(score = abs(Estimate)*(1-Pr...t..))

```

meh... doesn't look that great.  Wonder if we can quickly predict with it to check?

```{r checkinglinmod}

predictlm <- lm_app %>% predict(application_train_test.) %>% tibble()
colnames(predictlm) <- "Predicted_TARGET.lm"
application_train_test.lass <- application_train_test. %>% bind_cols(predictlm)
roc(response = application_train_test.lass$TARGET, predictor = predictlm$Predicted_TARGET.lm)

```

Time to do some summarising of the bureau data

```{r bureaufirst}

skim(bureau)

bureau %>% 
  head(n = 200000) %>% 
  ggplot(aes(x = CREDIT_CURRENCY))+
  geom_histogram(stat = "count")

bureau %>% 
  head(n = 800000) %>% 
  ggplot(aes(x = CREDIT_ACTIVE))+
  geom_histogram(stat = "count")

bureau %>%
  head(n = 500000) %>% 
  inner_join(application_train %>% select(TARGET, SK_ID_CURR), by = "SK_ID_CURR") %>% 
  ggplot(aes(x = CREDIT_TYPE))+
  geom_histogram(stat = "count")+
  facet_grid(TARGET ~.)+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

bureau_countsum <- bureau %>% 
  group_by(SK_ID_CURR) %>% 
  summarise(count = unique(SK_ID_BUREAU) %>% length())

bureau_countsum %>% 
  ggplot(aes(x = count))+
  geom_histogram(stat = "count")

```


```{r bureaursummariesing}


bureau_summ_index_recent <- bureau %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(DAYS_CREDIT) %>% 
  summarise(SK_ID_BUREAU = last(SK_ID_BUREAU))
bureau_summ_recent <- bureau %>%
  filter(SK_ID_BUREAU %in% bureau_summ_index_recent$SK_ID_BUREAU) %>% 
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL, DAYS_EMPLOYED), by = "SK_ID_CURR") %>% 
  mutate(AMT_CREDIT_MAX_OVERDUE.ratio.inc = AMT_CREDIT_MAX_OVERDUE/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_MAX_OVERDUE.ratio.annunity = AMT_CREDIT_MAX_OVERDUE/(AMT_ANNUITY+1),
         DAYS_ENDDATE_FACT.ratio.emp = DAYS_ENDDATE_FACT/(DAYS_EMPLOYED+1),
         AMT_CREDIT_SUM_DEBT.ratio.inc = AMT_CREDIT_SUM_DEBT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM_LIMIT.ratio.inc = AMT_CREDIT_SUM_LIMIT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM.ratio = AMT_CREDIT_SUM / (AMT_CREDIT_SUM/AMT_INCOME_TOTAL)) %>% 
  select(-SK_ID_BUREAU, -AMT_INCOME_TOTAL, -DAYS_EMPLOYED) 
colnames(bureau_summ_recent) <- colnames(bureau_summ_recent) %>% paste0(., ".recent")
colnames(bureau_summ_recent)[1] <- "SK_ID_CURR"

bureau_summ_index_early <- bureau %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(desc(DAYS_CREDIT)) %>% 
  summarise(SK_ID_BUREAU = last(SK_ID_BUREAU))
bureau_summ_early <- bureau %>% 
  filter(SK_ID_BUREAU %in% bureau_summ_index_early$SK_ID_BUREAU) %>% 
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL, DAYS_EMPLOYED), by = "SK_ID_CURR") %>% 
  mutate(AMT_CREDIT_MAX_OVERDUE.ratio.inc = AMT_CREDIT_MAX_OVERDUE/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_MAX_OVERDUE.ratio.annunity = AMT_CREDIT_MAX_OVERDUE/(AMT_ANNUITY+1),
         DAYS_ENDDATE_FACT.ratio.emp = DAYS_ENDDATE_FACT/(DAYS_EMPLOYED+1),
         AMT_CREDIT_SUM_DEBT.ratio.inc = AMT_CREDIT_SUM_DEBT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM_LIMIT.ratio.inc = AMT_CREDIT_SUM_LIMIT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM.ratio = AMT_CREDIT_SUM / (AMT_CREDIT_SUM/AMT_INCOME_TOTAL)) %>% 
  select(-SK_ID_BUREAU, -AMT_INCOME_TOTAL, -DAYS_EMPLOYED) 
colnames(bureau_summ_early) <- colnames(bureau_summ_early) %>% paste0(., ".early")
colnames(bureau_summ_early)[1] <- "SK_ID_CURR"

bureau_summ_index_large <- bureau %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(AMT_CREDIT_SUM) %>% 
  summarise(SK_ID_BUREAU = last(SK_ID_BUREAU))
bureau_summ_large <- bureau %>% 
  filter(SK_ID_BUREAU %in% bureau_summ_index_large$SK_ID_BUREAU) %>% 
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL, DAYS_EMPLOYED), by = "SK_ID_CURR") %>% 
  mutate(AMT_CREDIT_MAX_OVERDUE.ratio.inc = AMT_CREDIT_MAX_OVERDUE/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_MAX_OVERDUE.ratio.annunity = AMT_CREDIT_MAX_OVERDUE/(AMT_ANNUITY+1),
         DAYS_ENDDATE_FACT.ratio.emp = DAYS_ENDDATE_FACT/(DAYS_EMPLOYED+1),
         AMT_CREDIT_SUM_DEBT.ratio.inc = AMT_CREDIT_SUM_DEBT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM_LIMIT.ratio.inc = AMT_CREDIT_SUM_LIMIT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM.ratio = AMT_CREDIT_SUM / (AMT_CREDIT_SUM/AMT_INCOME_TOTAL)) %>% 
  select(-SK_ID_BUREAU, -AMT_INCOME_TOTAL, -DAYS_EMPLOYED) 
colnames(bureau_summ_large) <- colnames(bureau_summ_large) %>% paste0(., ".large")
colnames(bureau_summ_large)[1] <- "SK_ID_CURR"

bureau_summ_index_small <- bureau %>% 
  group_by(SK_ID_CURR) %>% 
  arrange(desc(AMT_CREDIT_SUM)) %>% 
  summarise(SK_ID_BUREAU = last(SK_ID_BUREAU))
bureau_summ_small <- bureau %>% 
  filter(SK_ID_BUREAU %in% bureau_summ_index_small$SK_ID_BUREAU) %>% 
  left_join(application_train %>% select(SK_ID_CURR, AMT_INCOME_TOTAL, DAYS_EMPLOYED), by = "SK_ID_CURR") %>% 
  mutate(AMT_CREDIT_MAX_OVERDUE.ratio.inc = AMT_CREDIT_MAX_OVERDUE/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_MAX_OVERDUE.ratio.annunity = AMT_CREDIT_MAX_OVERDUE/(AMT_ANNUITY+1),
         DAYS_ENDDATE_FACT.ratio.emp = DAYS_ENDDATE_FACT/(DAYS_EMPLOYED+1),
         AMT_CREDIT_SUM_DEBT.ratio.inc = AMT_CREDIT_SUM_DEBT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM_LIMIT.ratio.inc = AMT_CREDIT_SUM_LIMIT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM.ratio = AMT_CREDIT_SUM / (AMT_CREDIT_SUM/AMT_INCOME_TOTAL)) %>% 
  select(-SK_ID_BUREAU, -AMT_INCOME_TOTAL, -DAYS_EMPLOYED) 
colnames(bureau_summ_small) <- colnames(bureau_summ_small) %>% paste0(., ".small")
colnames(bureau_summ_small)[1] <- "SK_ID_CURR"


bureau_summ_summ <- bureau %>% 
  left_join(application_train %>% select(-AMT_ANNUITY), by = "SK_ID_CURR") %>% 
  mutate(AMT_CREDIT_MAX_OVERDUE.ratio.inc = AMT_CREDIT_MAX_OVERDUE/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_MAX_OVERDUE.ratio.annunity = AMT_CREDIT_MAX_OVERDUE/(AMT_ANNUITY+1),
         DAYS_ENDDATE_FACT.ratio.emp = DAYS_ENDDATE_FACT/(DAYS_EMPLOYED+1),
         AMT_CREDIT_SUM_DEBT.ratio.inc = AMT_CREDIT_SUM_DEBT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM_LIMIT.ratio.inc = AMT_CREDIT_SUM_LIMIT/(AMT_INCOME_TOTAL+1),
         AMT_CREDIT_SUM.ratio = AMT_CREDIT_SUM / (AMT_CREDIT_SUM/AMT_INCOME_TOTAL)) %>%
  group_by(SK_ID_CURR) %>% 
  summarise(bureau_record_count = SK_ID_BUREAU %>% unique() %>% length(),
            bureau_type_count = CREDIT_TYPE %>% unique() %>% length(),
            #bureau_type_mode = Mode(CREDIT_TYPE),
            AMT_CREDIT_MAX_OVERDUE.mean = mean(AMT_CREDIT_MAX_OVERDUE, na.rm = T),
            AMT_CREDIT_SUM.mean = mean(AMT_CREDIT_SUM, na.rm = T),
            DAYS_CREDIT_UPDATE = mean(DAYS_CREDIT_UPDATE, na.rm = T),
            DAYS_CREDIT.mean = mean(DAYS_CREDIT, na.rm = T),
            CREDIT_DAY_OVERDUE.mean = mean(CREDIT_DAY_OVERDUE, na.rm = T),
            AMT_ANNUNITY.mean = mean(AMT_ANNUITY, na.rm = T),
            DAYS_ENDDATE_FACT.ratio.emp.mean = mean(DAYS_ENDDATE_FACT.ratio.emp, na.rm = T),
            AMT_CREDIT_MAX_OVERDUE.sd = sd(AMT_CREDIT_MAX_OVERDUE, na.rm = T),
            AMT_CREDIT_SUM.sd = sd(AMT_CREDIT_SUM, na.rm = T),
            DAYS_CREDIT_UPDATE = sd(DAYS_CREDIT_UPDATE, na.rm = T),
            DAYS_CREDIT.sd = sd(DAYS_CREDIT, na.rm = T),
            CREDIT_DAY_OVERDUE.sd = sd(CREDIT_DAY_OVERDUE, na.rm = T),
            AMT_ANNUNITY.sd = sd(AMT_ANNUITY, na.rm = T),
            DAYS_ENDDATE_FACT.ratio.emp.sd = sd(DAYS_ENDDATE_FACT.ratio.emp, na.rm = T))

bureau_summ_master <- bureau_summ_summ %>% 
  left_join(bureau_summ_early, by = "SK_ID_CURR") %>% 
  left_join(bureau_summ_recent, by = "SK_ID_CURR") %>% 
  left_join(bureau_summ_large, by = "SK_ID_CURR") %>% 
  left_join(bureau_summ_small, by = "SK_ID_CURR") 
  
mod_rpart_bureau <- bureau_summ_master %>% 
  left_join(TARGET, by = "SK_ID_CURR") %>% 
  select(-SK_ID_CURR) %>% rpart(formula = TARGET ~., cp = .001)

summary(mod_rpart_bureau)
rpart.plot(mod_rpart_bureau)

colnames(application_train_train.)

bureau_summ_master <- bureau_summ_master %>% 
  left_join(previous_summ_master %>% select(SK_ID_CURR, DAYS_DECISION.app, DAYS_DECISION.dec, DAYS_DECISION.mean), by = "SK_ID_CURR") %>% 
  left_join(application_train %>% select(DAYS_EMPLOYED, SK_ID_CURR), by = "SK_ID_CURR") %>% 
  mutate(DAYS_CREDIT.mean.diff.DAYS_DECISION.app = DAYS_CREDIT.mean - DAYS_DECISION.app,
         DAYS_CREDIT.recent.diff.DAYS_DECISION.dec = DAYS_CREDIT.recent - DAYS_DECISION.dec,
         DAYS_CREDIT.large.diff.DAYS_DECISION.app = DAYS_CREDIT.large - DAYS_DECISION.app,
         DAYS_CREDIT.small.diff.DAYS_EMPLOYED = DAYS_CREDIT.small - DAYS_EMPLOYED,
         DAYS_CREDIT.recent.diff.DAYS_EMPLOYED = DAYS_CREDIT.recent - DAYS_EMPLOYED,
         DAYS_CREDIT.large.diff.DAYS_EMPLOYED = DAYS_CREDIT.large - DAYS_EMPLOYED) %>% 
  select(-DAYS_DECISION.app, -DAYS_DECISION.dec, -DAYS_DECISION.mean, -DAYS_EMPLOYED)

### checking to see how much damage we do by removing variables or observations
bureau %>% inner_join(application_train %>% select(SK_ID_CURR, TARGET), by = "SK_ID_CURR") %>%
  filter(!CREDIT_TYPE %in% c("Consumer credit", "Credit card", "Car loan", "Mortgage", "Microloan", "Loan for business development")) %>% 
  ggplot(aes(x = CREDIT_TYPE))+
  geom_histogram(stat = "count")+
  facet_grid(.~ TARGET)+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))


bureau_summ_master %>% select(contains("CREDIT_ACTIVE"), contains("CREDIT_TYPE"))

### removing some problem variables, maybe this won't be necessary in the whole training and test set
bureau_summ_master <- bureau_summ_master %>% 
  select(-contains("CURRENCY"))

bureau_summ_master <- bureau_summ_master %>% 
  select(-contains("CREDIT_ACTIVE"))

bureau_summ_master <- bureau_summ_master %>% 
  mutate(CREDIT_TYPE.early = case_when(CREDIT_TYPE.early %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ "Too small a type",
                                       !CREDIT_TYPE.early %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ CREDIT_TYPE.early),
         CREDIT_TYPE.recent = case_when(CREDIT_TYPE.recent %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ "Too small a type",
                                       !CREDIT_TYPE.recent %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ CREDIT_TYPE.recent),
         CREDIT_TYPE.small = case_when(CREDIT_TYPE.small %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ "Too small a type",
                                       !CREDIT_TYPE.small %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ CREDIT_TYPE.small),
         CREDIT_TYPE.large = case_when(CREDIT_TYPE.large %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ "Too small a type",
                                       !CREDIT_TYPE.large %in% c("Loan for purchase of shares (margin lending)", "Real estate loan", "Interbank credit", "Mobile operator loan", "Cash loan (non-earmarked)", "Unknown type of loan") ~ CREDIT_TYPE.large))


            
```

Time to join in onto the exising df and test it with xgboost

```{r xgbtestingbureau}


# application_train_train <- application_train_train.
# application_train_test <- application_train_test.


application_train_train. <- application_train_train %>% 
  left_join(bureau_summ_master, by = "SK_ID_CURR") 

application_train_test. <- application_train_test %>% 
  left_join(bureau_summ_master, by = "SK_ID_CURR")

## Option to thin some variables by brute force
# application_train_train. <- application_train_train %>% 
#   left_join(bureau_summ_master, by = "SK_ID_CURR") %>% 
#   select(-contains(".early"), -contains(".small"),-contains(".dec"), -contains(".mode"))
# 
# application_train_test. <- application_train_test %>% 
#   left_join(bureau_summ_master, by = "SK_ID_CURR")%>% 
#   select(-contains(".early"), -contains(".small"),-contains(".dec"), -contains(".mode"))

#skim(application_train_train.)
 

application_train_train.[is.na(application_train_train.)] <- -10000000
application_train_test.[is.na(application_train_test.)] <- -10000000

### Without the highly cardinal features
 train <- list(sparse.model.matrix(~., data = application_train_train. %>% select(-SK_ID_CURR, -TARGET,  -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>%  filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA")), application_train_train. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA") %>%  pull(TARGET))
 names(train) <- c("data", "label")
 test <- list(sparse.model.matrix( ~ ., data = application_train_test. %>% select(-SK_ID_CURR, -TARGET, -OCCUPATION_TYPE, -ORGANIZATION_TYPE, -contains("Predicted_TARGET")) %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA")), application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave", NAME_CONTRACT_TYPE.app != "XNA") %>%  pull(TARGET))
 names(test) <- c("data", "label")
 
testch <- train %>% sample(20000)
 
 ### potential problem vars
 # - NAME_FAMILY_STATUS, - NAME_INCOME_TYPE, -OWN_CAR_AGE, NAME_CONTRACT_TYPE != "appXNA"

# application_train_train %>% select(-TARGET, -OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique() == application_train_test %>% select(-TARGET, - OWN_CAR_AGE, -contains("Predicted_TARGET")) %>% colnames() %>% unique()
# 
train[["data"]]@Dimnames[[2]] %in% test[["data"]]@Dimnames[[2]] #%>% unique()
 test[["data"]]@Dimnames[[2]] %in% train[["data"]]@Dimnames[[2]] 
 
badtrain <- which(!train[["data"]]@Dimnames[[2]] %in% test[["data"]]@Dimnames[[2]])
badtest <- which(!test[["data"]]@Dimnames[[2]] %in% train[["data"]]@Dimnames[[2]])

train_namelist <- train[["data"]]@Dimnames[[2]]
test_namelist <- test[["data"]]@Dimnames[[2]]

problemfinder <- function(namelist, badlist){
  listy <- c()
  for(i in 1:length(badlist)){
    listy <- c(listy,(namelist[badlist[i]]))
  }
 
  listy
}

problemfinder(train_namelist, badtrain)
problemfinder(test_namelist, badtest)

train[["data"]]@Dimnames[[2]][398]
 
badtest <- which(!test[["data"]]@Dimnames[[2]] %in% train[["data"]]@Dimnames[[2]])

 
 dtrain <- xgb.DMatrix(data = train$data, label=train$label)
 dtest <- xgb.DMatrix(data = test$data, label=test$label)
 watchlist <- list(train=dtrain, test=dtest)
#
 #mod_xgb_lin <- xgb.train(data = dtrain, booster = "gblinear",  nrounds = 50, watchlist = watchlist)
 mod_xgb_tree_inst <- xgb.train(data = dtrain,  booster = "gbtree", eta = .1, nrounds = 160, watchlist = watchlist)

 
prediction <- predict(mod_xgb_tree_inst, test$data) %>% tibble()
colnames(prediction) <- c("Predicted_TARGET_xgb_tree_inst_prev")
application_train_test.ass <- application_train_test. %>% filter(CODE_GENDER != "XNA", NAME_FAMILY_STATUS != "Unknown", NAME_INCOME_TYPE != "Pensioner", NAME_INCOME_TYPE != "Maternity leave") %>%  bind_cols(prediction)
head(application_train_test.ass$Predicted_TARGET_xgb_tree_inst_prev)
roc(response = application_train_test.ass$TARGET, predictor = prediction$Predicted_TARGET_xgb_tree_inst_prev)

imp <- xgb.importance(model = mod_xgb_tree_inst)
imp %>% 
  filter((Gain) > .0035, (Cover > .0035)) %>% 
  ggplot(aes(x = log(Gain), y = log(Cover), col = (Frequency)))+
  geom_point()+
  scale_color_gradientn(colours = rainbow(10))+
  geom_text(aes(label = Feature))

skim(application_train_train.)


```